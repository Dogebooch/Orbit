interface VisionData {
  problem: string;
  target_user: string;
  success_metrics: string;
  why_software: string;
  target_level?: string;
  ai_challenge_response?: string;
}

interface UserProfileData {
  primary_user: string;
  goal: string;
  context: string;
  frustrations: string;
  technical_comfort: string;
  time_constraints: string;
  persona_name?: string;
  persona_role?: string;
  device_preference?: string;
}

interface SuccessMetricsData {
  target_level: string;
  criteria: string[];
  validation_methods: string[];
  timeline: string;
}

const TARGET_LEVEL_LABELS: Record<string, string> = {
  poc: 'Proof of Concept',
  mvp: 'MVP (Minimum Viable Product)',
  demo: 'Polished Demo',
  production: 'Production Ready',
};

const TARGET_LEVEL_DESCRIPTIONS: Record<string, string> = {
  poc: 'Demonstrates core functionality. May have rough edges, limited error handling.',
  mvp: 'Minimally viable for real users to test. Core features work reliably.',
  demo: 'Ready for presentations or investor demos. Looks professional, handles common paths well.',
  production: 'Can handle real users and edge cases. Proper error handling, security, performance.',
};

const TECHNICAL_COMFORT_DESCRIPTIONS: Record<string, string> = {
  low: 'Low - Needs simple, guided interfaces with no jargon. Use wizards and step-by-step flows.',
  medium: 'Medium - Comfortable with standard apps. Understands basic patterns like forms, lists, dashboards.',
  high: 'High - Power user who appreciates keyboard shortcuts, bulk actions, advanced filters.',
};

export function visionToMarkdown(vision: VisionData): string {
  const sections: string[] = [];

  sections.push('# Project Vision');
  sections.push('');
  sections.push('> This document defines the core problem, target user, and success criteria for this project.');
  sections.push('> It serves as the foundation for all AI-assisted development decisions.');
  sections.push('');

  sections.push('## Problem Statement');
  if (vision.problem) {
    sections.push(vision.problem);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Target User');
  if (vision.target_user) {
    sections.push(vision.target_user);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Why Custom Software?');
  if (vision.why_software) {
    sections.push(vision.why_software);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Target Level');
  const level = vision.target_level || 'mvp';
  sections.push(`**${TARGET_LEVEL_LABELS[level] || level}**`);
  sections.push('');
  sections.push(TARGET_LEVEL_DESCRIPTIONS[level] || '');
  sections.push('');

  sections.push('## Success Metrics');
  if (vision.success_metrics) {
    sections.push(vision.success_metrics);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  if (vision.ai_challenge_response) {
    sections.push('---');
    sections.push('');
    sections.push('## AI Challenge: Stress-Testing This Idea');
    sections.push('');
    sections.push('> The following questions were generated by AI to challenge assumptions');
    sections.push('> and identify potential gaps in the project vision.');
    sections.push('');
    sections.push(vision.ai_challenge_response);
    sections.push('');
  }

  return sections.join('\n');
}

export function userProfileToMarkdown(profile: UserProfileData): string {
  const sections: string[] = [];

  sections.push('# User Profile');
  sections.push('');
  sections.push('> This document describes the target user persona, their goals, context, and constraints.');
  sections.push('> Use this to guide UX decisions and prioritize features.');
  sections.push('');

  sections.push('## Primary User Persona');
  if (profile.persona_name || profile.persona_role) {
    sections.push(`**${profile.persona_name || 'User'}**${profile.persona_role ? ` - ${profile.persona_role}` : ''}`);
    sections.push('');
  }
  if (profile.primary_user) {
    sections.push(profile.primary_user);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## User Goal (Job-to-be-Done)');
  if (profile.goal) {
    sections.push(profile.goal);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Usage Context');
  if (profile.context) {
    sections.push(profile.context);
  } else {
    sections.push('_Not yet defined_');
  }
  if (profile.device_preference) {
    sections.push('');
    sections.push(`**Primary Device:** ${profile.device_preference}`);
  }
  sections.push('');

  sections.push('## Current Frustrations');
  if (profile.frustrations) {
    sections.push(profile.frustrations);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Technical Comfort Level');
  const comfort = profile.technical_comfort || 'medium';
  sections.push(TECHNICAL_COMFORT_DESCRIPTIONS[comfort] || comfort);
  sections.push('');

  sections.push('## Time Constraints');
  if (profile.time_constraints) {
    sections.push(profile.time_constraints);
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('---');
  sections.push('');
  sections.push('## UX Design Implications');
  sections.push('');
  sections.push('Based on this user profile, the interface should:');
  sections.push('');

  const implications: string[] = [];

  if (comfort === 'low') {
    implications.push('- Use simple, guided interfaces with clear step-by-step flows');
    implications.push('- Avoid technical jargon and abbreviations');
    implications.push('- Provide clear feedback for every action');
    implications.push('- Include helpful tooltips and inline help');
  } else if (comfort === 'high') {
    implications.push('- Support keyboard shortcuts and power-user features');
    implications.push('- Allow bulk actions and advanced filtering');
    implications.push('- Provide customization options');
    implications.push('- Keep interface dense but organized');
  } else {
    implications.push('- Use standard web app patterns (forms, lists, dashboards)');
    implications.push('- Balance simplicity with capability');
    implications.push('- Provide progressive disclosure for advanced features');
  }

  if (profile.time_constraints && profile.time_constraints.toLowerCase().includes('minute')) {
    implications.push('- Optimize for speed - minimize clicks and loading times');
    implications.push('- Use smart defaults and auto-fill where possible');
  }

  sections.push(...implications);
  sections.push('');

  return sections.join('\n');
}

export function successMetricsToMarkdown(vision: VisionData): string {
  const sections: string[] = [];

  sections.push('# Success Metrics');
  sections.push('');
  sections.push('> This document defines how success will be measured for this project.');
  sections.push('> Use these criteria to validate your solution and know when you\'re done.');
  sections.push('');

  sections.push('## Target Level');
  const level = vision.target_level || 'mvp';
  sections.push(`**${TARGET_LEVEL_LABELS[level] || level}**`);
  sections.push('');
  sections.push(TARGET_LEVEL_DESCRIPTIONS[level] || '');
  sections.push('');

  sections.push('## Success Criteria');
  if (vision.success_metrics) {
    const metrics = vision.success_metrics.split('\n').filter(line => line.trim());
    metrics.forEach((metric, index) => {
      const cleaned = metric.replace(/^[-*]\s*/, '').replace(/^\d+\.\s*/, '');
      sections.push(`${index + 1}. ${cleaned}`);
    });
  } else {
    sections.push('_Not yet defined_');
  }
  sections.push('');

  sections.push('## Validation Checklist');
  sections.push('');
  sections.push('Use this checklist to validate your solution:');
  sections.push('');
  sections.push('- [ ] Core functionality works end-to-end');
  sections.push('- [ ] Target user can complete primary task without help');
  sections.push('- [ ] Performance meets acceptable thresholds');
  sections.push('- [ ] Error handling covers common failure cases');
  if (level === 'production') {
    sections.push('- [ ] Security review completed');
    sections.push('- [ ] Load testing performed');
    sections.push('- [ ] Monitoring and alerting configured');
  }
  sections.push('');

  return sections.join('\n');
}

export function markdownToVision(markdown: string): Partial<VisionData> {
  const vision: Partial<VisionData> = {};

  const problemMatch = markdown.match(/## Problem(?: Statement)?\s*\n([\s\S]*?)(?=\n## |$)/);
  if (problemMatch) {
    vision.problem = problemMatch[1].trim().replace(/^_Not yet defined_$/, '');
  }

  const targetUserMatch = markdown.match(/## Target User\s*\n([\s\S]*?)(?=\n## |$)/);
  if (targetUserMatch) {
    vision.target_user = targetUserMatch[1].trim().replace(/^_Not yet defined_$/, '');
  }

  const successMetricsMatch = markdown.match(/## Success (Metrics|Criteria)\s*\n([\s\S]*?)(?=\n## |$)/);
  if (successMetricsMatch) {
    vision.success_metrics = successMetricsMatch[2].trim().replace(/^_Not yet defined_$/, '');
  }

  const whySoftwareMatch = markdown.match(/## Why (Software\?|Custom Software\?)\s*\n([\s\S]*?)(?=\n## |$)/);
  if (whySoftwareMatch) {
    vision.why_software = whySoftwareMatch[2].trim().replace(/^_Not yet defined_$/, '');
  }

  const challengeMatch = markdown.match(/## AI Challenge[^\n]*\n[\s\S]*?>\s*[^\n]+\n([\s\S]*?)(?=\n---|\n## |$)/);
  if (challengeMatch) {
    vision.ai_challenge_response = challengeMatch[1].trim();
  }

  return vision;
}

export function markdownToUserProfile(markdown: string): Partial<UserProfileData> {
  const profile: Partial<UserProfileData> = {};

  const personaMatch = markdown.match(/\*\*([^*]+)\*\*\s*-?\s*([^*\n]*)/);
  if (personaMatch) {
    profile.persona_name = personaMatch[1].trim();
    profile.persona_role = personaMatch[2]?.trim() || '';
  }

  const primaryUserMatch = markdown.match(/## Primary User(?: Persona)?\s*\n(?:\*\*[^*]+\*\*[^\n]*\n\n)?([\s\S]*?)(?=\n## |$)/);
  if (primaryUserMatch) {
    profile.primary_user = primaryUserMatch[1].trim().replace(/^_Not yet defined_$/, '');
  }

  const goalMatch = markdown.match(/## User Goal[^\n]*\s*\n([\s\S]*?)(?=\n## |$)/);
  if (goalMatch) {
    profile.goal = goalMatch[1].trim().replace(/^_Not yet defined_$/, '');
  }

  const contextMatch = markdown.match(/## (Usage )?Context\s*\n([\s\S]*?)(?=\n## |$)/);
  if (contextMatch) {
    profile.context = contextMatch[2].trim().replace(/^_Not yet defined_$/, '');
  }

  const frustrationsMatch = markdown.match(/## (Current )?Frustrations\s*\n([\s\S]*?)(?=\n## |$)/);
  if (frustrationsMatch) {
    profile.frustrations = frustrationsMatch[2].trim().replace(/^_Not yet defined_$/, '');
  }

  const technicalComfortMatch = markdown.match(/## Technical Comfort[^\n]*\s*\n([\s\S]*?)(?=\n## |$)/);
  if (technicalComfortMatch) {
    const content = technicalComfortMatch[1].trim();
    if (content.toLowerCase().includes('low')) {
      profile.technical_comfort = 'low';
    } else if (content.toLowerCase().includes('high')) {
      profile.technical_comfort = 'high';
    } else {
      profile.technical_comfort = 'medium';
    }
  }

  const timeConstraintsMatch = markdown.match(/## Time Constraints\s*\n([\s\S]*?)(?=\n## |$)/);
  if (timeConstraintsMatch) {
    profile.time_constraints = timeConstraintsMatch[1].trim().replace(/^_Not yet defined_$/, '');
  }

  return profile;
}
